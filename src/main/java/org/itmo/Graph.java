package org.itmo;

import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicIntegerArray;

class Graph {
    private final int V;
    private final ArrayList<Integer>[] adjList;
    private final int threadPoolSize;
    private AtomicIntegerArray visited;

    Graph(int vertices) {
        this(vertices, Runtime.getRuntime().availableProcessors());
    }


    Graph(int vertices, int threadPoolSize) {
        this.V = vertices;
        this.threadPoolSize = threadPoolSize;
        this.visited = new AtomicIntegerArray(vertices);
        adjList = new ArrayList[vertices];
        for (int i = 0; i < vertices; ++i) {
            adjList[i] = new ArrayList<>();
        }
    }

    void addEdge(int src, int dest) {
        if (!adjList[src].contains(dest)) {
            adjList[src].add(dest);
        }
    }

    void parallelBFS(int startVertex) {
        this.visited = new AtomicIntegerArray(V);
        ConcurrentLinkedQueue<Integer> currentLevelQueue = new ConcurrentLinkedQueue<>();
        ConcurrentLinkedQueue<Integer> nextLevelQueue = new ConcurrentLinkedQueue<>();

        visited.set(startVertex, 1);
        currentLevelQueue.add(startVertex);

        ExecutorService executor = Executors.newFixedThreadPool(threadPoolSize);
        CyclicBarrier levelBarrier = new CyclicBarrier(threadPoolSize);

        try {
            int level = 0;

            while (!currentLevelQueue.isEmpty()) {
//                System.out.println("Processing level " + level +
//                        ", verteces: " + currentLevelQueue.size());

                // Запускаем воркеров для текущего уровня
                List<Future<?>> futures = new ArrayList<>();
                for (int i = 0; i < threadPoolSize; i++) {
                    futures.add(executor.submit(createLevelWorker(
                            currentLevelQueue, nextLevelQueue, visited, levelBarrier
                    )));
                }

                // Ждем завершения уровня
                for (Future<?> future : futures) {
                    future.get();
                }

                // Подготовка к следующему уровню
                currentLevelQueue = nextLevelQueue;
                nextLevelQueue = new ConcurrentLinkedQueue<>();
                level++;
            }
        } catch (InterruptedException | ExecutionException e) {
            Thread.currentThread().interrupt();
        } finally {
            executor.shutdown();
        }
    }

    private Runnable createLevelWorker(ConcurrentLinkedQueue<Integer> currentQueue,
                                       ConcurrentLinkedQueue<Integer> nextQueue,
                                       AtomicIntegerArray visited,
                                       CyclicBarrier barrier) {
        return () -> {
            try {
                Integer vertex;
                while ((vertex = currentQueue.poll()) != null) {
                    for (int neighbor : adjList[vertex]) {
                        if (visited.compareAndSet(neighbor, 0, 1)) {
                            nextQueue.add(neighbor);
                        }
                    }
                }
                // Синхронизация на барьере
                barrier.await();
            } catch (Exception e) {
                Thread.currentThread().interrupt();
            }
        };
    }

    //Generated by ChatGPT
    void bfs(int startVertex) {
        boolean[] visited = new boolean[V];

        LinkedList<Integer> queue = new LinkedList<>();

        visited[startVertex] = true;
        queue.add(startVertex);

        while (!queue.isEmpty()) {
            startVertex = queue.poll();

            for (int n : adjList[startVertex]) {
                if (!visited[n]) {
                    visited[n] = true;
                    queue.add(n);
                }
            }
        }
    }

    void generateTree(int branchingFactor) {
        // Очищаем граф
        for (int i = 0; i < V; i++) {
            adjList[i].clear();
        }

        Queue<Integer> queue = new LinkedList<>();
        int nextVertex = 1; // Следующая вершина для добавления (0 уже корень)

        queue.add(0); // Начинаем с корня

        while (!queue.isEmpty() && nextVertex < V) {
            int current = queue.poll();

            // Добавляем до branchingFactor детей к текущей вершине
            for (int i = 0; i < branchingFactor && nextVertex < V; i++) {
                addEdge(current, nextVertex);
                queue.add(nextVertex);
                nextVertex++;
            }
        }
    }

    void visualizeAsGraphViz() {
        System.out.println("Граф в формате GraphViz:");
        System.out.println("========================");

        for (int i = 0; i < V; i++) {
            if (!adjList[i].isEmpty()) {
                for (int neighbor : adjList[i]) {
                    System.out.println("  \"" + i + "\" -> \"" + neighbor + "\"");
                }
            }
        }
    }

    public boolean isVisited(int vertex) {
        return visited.get(vertex) >= 1;
    }

    public int getVisitedCount() {
        int count = 0;
        for (int i = 0; i < V; i++) {
            if (visited.get(i) == 1) count++;
            if (visited.get(i) != 1) System.out.println("Vertex" + i + " not visited");
        }
        return count;
    }
}
